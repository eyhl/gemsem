import numpy as np
from scipy import stats
import cartopy.crs as ccrs
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from matplotlib.gridspec import GridSpec
import matplotlib.path as mpath
from gemsem.utils import design_SHA
import matplotlib.ticker as ticker



def plot_field_map(model, feature, radius, **kwargs):
    """
    This function plots the synthetic values generated by a given spherical harmonic model within the domain of
    geomagnetism. It computes the design matrix G, based on the length of the input model, m, and uses it in the
    forward problem:
        d = G.m
    The user has several options for plotting different field features in different plotting views. This function
    serves well as a first investigation of a given model, but it is not flexible for more advanced visualisation
    goals. The user is encouraged to visit https://scitools.org.uk/cartopy for learning how to use cartopy for
    plotting, which is relatively simply. The complexity of the below function is due to the different options
    given, but a cartopy map projection can actually be carried out in a few lines of code.

    Args:
        model (ndarray): model coefficients used for computing d = G.m, where m is the model
        feature (str): geomagnetic field feature to be plotted, options: 'B_r', 'B_t', 'B_p', 'F', 'D', 'I' or 'H'
        radius (float): the radius at which the synthetic field values should be generated

    **kwargs (optional):
        value_limits (float list): upper and lower value limits e.g. [-1e3, 1e3]
        mesh_size (float): mesh size for the synthetic grid, below .5 computations are heavy
        lat_limits (float list): limits on latitude, order does not matter e.g. [90, -90]
        lon_limits (float list): limits on longitude, order does not matter e.g. [-180, 180]
        main_projection (object): Cartopy projection object e.g. ccrs.Mollweide()
                                  for full list of projections see: https://scitools.org.uk/cartopy
        plot_poles (boolean): Whether to plot poles or not, default is True
        polar_limit (float): Bounding latitude for the polar plots default is 60N and 60S
        contour_labels (float list): list of contour line labels plotted if feature=='D'
                                     e.g. [-30, -15, -5, 0, 5, 15, 30]
        microtesla (boolean): Set to false for plotting in nanoTesla
        savefig (boolean): save figure True/False
        colormap (str): Choose from matplotlibs color map options e.g. 'PuOr_r' or 'RdBu'
        title_string (str): set a customized title string
        colorbar_string (str):  set a customized colorbar string
        figure_size (float tuple): figure size, (width, height) in inches.
        title_pos (float): position of the title text, e.g. 1.1
        label_pos (int): spacing in points between the colobar label and the x-axis.

    Returns:
        None

    Notes:
        - Contour lines are only plotted on declination plots
        - Contour lines are omitted in polar plots. Calling the function with plot_poles=False and
          projection_type=ccrs.LambertAzimuthalEqualArea(), will produce a polar plot with contours.

    Examples:
        # Example1
        model = np.loadtxt('coefficients_L2.txt')
        plot_feature = 'B_r'
        radius_core = 3480.
        plot_field_map(model, plot_feature, radius_core)

        # Example2:
        plot_feature = 'D'
        radius_surface = 6371.2
        plot_field_map(model, plot_feature, radius_surface, value_limits=[-40, 40], no_poles=True, colormap='RdBu')

    @author: Eigil Y. H. Lippert, Student DTU Space, <s132561@student.dtu.dk>
    """


    # set default values
    value_limits = [-1e3, 1e3]
    mesh_size = 1
    lat_limits = [90, -90]
    lon_limits = [-180, 180]
    main_projection = ccrs.Mollweide()
    plot_poles = True
    polar_limit = 60
    contour_labels = [-30, -15, -5, 0, 5, 15, 30]
    microtesla = True
    savefig = False
    colormap = 'PuOr_r'
    title_string = None
    colorbar_string = None
    figure_size = (12, 12)
    title_pos = 1.
    label_pos = 5.


    # update defaults based on used input
    for key, value in kwargs.items():
        if key == 'value_limits':
            value_limits = value
        elif key == 'mesh_size':
            mesh_size = value
        elif key == 'lat_limits':
            lat_limits = value
        elif key == 'lon_limits':
            lon_limits = value
        elif key == 'main_projection':
            main_projection = value
        elif key == 'plot_poles':
            plot_poles = value
        elif key == 'polar_limit':
            polar_limit = value
        elif key == 'contour_labels':
            contour_labels = value
        elif key == 'microtesla':
            microtesla = value
        elif key == 'savefig':
            savefig = value
        elif key == 'colormap':
            colormap = value
        elif key == 'title_string':
            title_string = value
        elif key == 'colorbar_string':
            colorbar_string = value
        elif key == 'figure_size':
            figure_size = value
        elif key == 'title_pos':
            title_pos = value
        elif key == 'label_pos':
            label_pos = value

    # set constants
    degree = int(-1 + np.sqrt(1 + len(model)))
    r_surface = 6371.2
    rad = np.pi / 180
    lat_bound = [np.max(lat_limits), np.min(lat_limits)]
    lon_bound = [np.min(lon_limits), np.max(lon_limits)]

    # make range of lat/lon
    lat = 90 - np.arange(lat_bound[0], lat_bound[1] - mesh_size, -mesh_size)  # lat/theta array between 90 and 90
    lon = np.arange(lon_bound[0], lon_bound[1] + mesh_size, mesh_size)

    # remove pole points
    lat = np.delete(lat, np.where(lat == 0))
    lat = np.delete(lat, np.where(lat == 180.))

    # compute(lat, lon) - grid
    lon_grid, lat_grid = np.meshgrid(lon, lat)
    rows, cols = np.shape(lon_grid)

    # reshape for design_SHA to work
    lon_grid = lon_grid.reshape(-1, )
    lat_grid = lat_grid.reshape(-1, )

    [Gr, Gt, Gp] = design_SHA(radius / r_surface, lat_grid * rad, lon_grid * rad, degree)
    G = np.vstack((Gr, Gt, Gp))

    # compute synthetic field
    B_synth = G.dot(model)

    # seperate into components
    step = int(len(B_synth) / 3)
    Br_synth = B_synth[0:step]
    Bt_synth = B_synth[step:step * 2]
    Bp_synth = B_synth[step * 2::]

    # reshape back for pcolormesh to work
    lon_grid = lon_grid.reshape(rows, cols)
    lat_grid = (90 - lat_grid).reshape(rows, cols)

    # reshape field components into size of grid as well
    Br_synth = Br_synth.reshape(rows, cols)
    Bt_synth = Bt_synth.reshape(rows, cols)
    Bp_synth = Bp_synth.reshape(rows, cols)

    # chosen feature:
    for feature_name in [feature]:
        if feature_name == 'B_r':
            feature_name = feature_name + '-component'
            # compute Br component
            feat = Br_synth
            unit = 'B_r, [nT]'
            if microtesla:
                feat = feat * 1e-3
                unit = 'B_r, [\mu T]'
        elif feature_name == 'B_t':
            feature_name = feature_name + '-component'
            # compute Bt component
            feat = Bt_synth
            unit = 'B_t, [nT]'
            if microtesla:
                feat = feat * 1e-3
                unit = 'B_t, [\mu T]'
        elif feature_name == 'B_p':
            feature_name = feature_name + '-component'
            # compute Bp component
            feat = Bp_synth
            unit = 'B_p, [nT]'
            if microtesla:
                feat = feat * 1e-3
                unit = 'B_p, [\mu T]'
        elif feature_name == 'F':
            feature_name = feature_name + ', field intensity'
            # compute F, intensity
            feat = np.sqrt(Br_synth ** 2 + Bt_synth ** 2 + Bp_synth ** 2)
            unit = 'F, [nT]'
            if microtesla:
                feat = feat * 1e-3
                unit = 'F, [\mu T]'

        elif feature_name == 'D':
            feature_name = feature_name + ', declination'
            X_synth = -Bt_synth
            Y_synth = Bp_synth
            # compute D, declination
            feat = np.arctan2(Y_synth, X_synth) * 180 / np.pi
            unit = 'D, [degree]'
        elif feature_name == 'I':
            feature_name = feature_name + ', inclination'
            X_synth = -Bt_synth
            Y_synth = Bp_synth
            Z_synth = -Br_synth
            H_synth = np.sqrt(X_synth ** 2 + Y_synth ** 2)
            # compute I, inclination
            feat = np.arctan2(Z_synth, H_synth) * 180 / np.pi
            unit = 'I, [degree]'
        elif feature_name == 'H':
            feature_name = feature_name + ', horisontal component'
            X_synth = -Bt_synth
            Y_synth = Bp_synth
            # compute H, horisontal component
            feat = np.sqrt(X_synth ** 2 + Y_synth ** 2)
            unit = 'H, [nT]'
            if microtesla:
                feat = feat * 1e-3
                unit = 'H, [\mu T]'
        else:
            print('Feature not known please choose B_r, B_t, B_p, F, D, I or H')

        # creates a list of projections for a combined main projection polar projection figure
        projections = [main_projection,
                       ccrs.LambertAzimuthalEqualArea(central_longitude=0., central_latitude=90.),
                       ccrs.LambertAzimuthalEqualArea(central_longitude=0., central_latitude=-90.)]

        # if no poles, only use one figure position
        if not plot_poles:
            subplot_position = [(0, 0)]
        else:
            subplot_position = [(0, 0), (2, 0), (2, 2)]
            colspan = 4

        f = plt.figure(figsize=figure_size)
        gs = GridSpec(4, 4, figure=f)

        for i, pos in enumerate(subplot_position):
            # change colspan for polar plots
            if i > 0:
                colspan = 2

            if not plot_poles:
                ax = plt.subplot(projection=projections[0])
            else:
                ax = plt.subplot(gs.new_subplotspec(pos, colspan=colspan, rowspan=2), projection=projections[i])

            # select polar values of interest for pcolormesh.
            if (i == 1) or (i == 2):
                lat_bound = [(90, 60), (-90, -60)]
                if i == 1:
                    lat_bound = [90, polar_limit]
                    polar_mask = lat_grid >= lat_bound[1]
                elif i == 2:
                    lat_bound = [-90, -polar_limit]
                    polar_mask = lat_grid <= lat_bound[1]

                # the masked array is 1-d so reshape with same number of columns as before:
                lat_grid_polar = np.reshape(lat_grid[polar_mask], (-1, lat_grid.shape[1]))
                b_r_polar = np.reshape(feat[polar_mask], (-1, lon_grid.shape[1]))
                lon_grid_polar = lon_grid[0:lat_grid_polar.shape[0], :]
                h1 = ax.pcolormesh(lon_grid_polar, lat_grid_polar, b_r_polar, cmap=colormap,
                                   transform=ccrs.PlateCarree(),
                                   vmin=value_limits[0], vmax=value_limits[1])

                ax.set_extent([-180, 180, lat_bound[0], lat_bound[1]], ccrs.PlateCarree())

                # make circular boundary on projection
                theta = np.linspace(0, 2 * np.pi, 100)
                center, radius = [0.5, 0.5], 0.5
                verts = np.vstack([np.sin(theta), np.cos(theta)]).T
                circle = mpath.Path(verts * radius + center)
                ax.set_boundary(circle, transform=ax.transAxes)

            else:
                # If declination draw contour lines
                if unit == 'D, [degree]':
                    feat_flatten = feat.flatten()
                    lon_grid_flatten = lon_grid.flatten()
                    lat_grid_flatten = lat_grid.flatten()
                    h1 = ax.scatter(x=lon_grid_flatten, y=lat_grid_flatten, s=20, c=feat_flatten, edgecolors='none',
                                    transform=ccrs.PlateCarree(), cmap=colormap, vmin=value_limits[0],
                                    vmax=value_limits[1])
                    c1 = ax.contour(lon, 90 - lat, feat, contour_labels, colors='black',
                                    linewidths=2.5, linestyles='solid', alpha=0.6, transform=ccrs.PlateCarree())
                    cl = plt.clabel(c1, fontsize=10, colors='k', inline=1, inline_spacing=8,
                                    fmt='%i', rightside_up=True, use_clabeltext=True)
                else:
                    h1 = ax.pcolormesh(lon_grid, lat_grid, feat, cmap=colormap, transform=ccrs.PlateCarree(),
                                       vmin=value_limits[0], vmax=value_limits[1])

            ax.coastlines(linewidth=1.1)

            ax.gridlines()

            # we need to set axes_class=plt.Axes, else it attempts to create a GeoAxes as colorbar
            if i == 0:
                divider = make_axes_locatable(ax)
                ax_cb = divider.new_vertical(size="5%", pad=0.1, axes_class=plt.Axes, pack_start=True)

                f.add_axes(ax_cb)

                # colorbar and properties
                cbar = plt.colorbar(h1, cax=ax_cb, orientation="horizontal")
                if colorbar_string is None:
                    colorbar_string = r'${}$'.format(unit)

                cbar.set_label(colorbar_string, rotation=0, labelpad=label_pos, fontsize='xx-large')
                cbar.ax.tick_params(labelsize=15)
                if title_string is None:
                    title_string = 'Field map of {}'.format(feature_name)
                ax.set_title(title_string,
                             weight='bold', fontsize='xx-large', y=title_pos)

        if savefig:
            plt.savefig('Field_map_of_the_{}_component'.format(feature_name) + '.png')

        plt.show()

        return


def plot_hist_residuals(residuals, fit=True, savefig=False, pdf_type="laplace", title='Histogram of residuals'):
    """
    Plots errors of a model. Default plots only histogram.

    Args:
        residuals (float ndarray): residuals/errors of the model to be evaluated
        fit (str): choose fit type 'laplace', 'normal' or False for no fitting
        savefig (boolean): choose to save figure or not
        pdf_type (str): choose the wished for type of probability density function

    Returns:
        None

    @author: Eigil Y. H. Lippert, Student DTU Space, <s132561@student.dtu.dk>

    """

    if pdf_type == "laplace":
        # create histogram of residuals
        plt.hist(residuals, bins=len(residuals), density=True)
        xt = plt.xticks()[0]

        if fit:
            xmin, xmax = min(xt), max(xt)
            lnspc = np.linspace(xmin, xmax, len(residuals))
            # fit laplace distribution to histogram
            m, s = stats.laplace.fit(residuals)  # get mean and standard deviation
            pdf_g = stats.laplace.pdf(lnspc, m, s)  # now get theoretical values in the interval
            plt.plot(lnspc, pdf_g, label="Laplace pdf fit")  # plot it
            if title == 'Histogram of residuals':
                title = 'Histogram of residuals' + ',' + r'$\bf{\mu=%.3f,\ \sigma=%.3f}$' % (m, s)
            plt.title(title, fontsize=14)
        else:
            plt.title(title, fontsize=14)

        plt.xlabel('Error values, [nT]', fontsize=14)
        plt.ylabel('Count', fontsize=14)
        ax = plt.gca()
        ax.yaxis.grid(which='major', color='grey', linestyle='dashed')
        ax.xaxis.grid(which='major', color='grey', linestyle='dashed')
        ax.set_axisbelow(True)

    elif pdf_type == "normal":
        # create histogram of residuals
        plt.hist(residuals, bins=len(residuals), density=True)
        xt = plt.xticks()[0]
        if fit:
            xmin, xmax = min(xt), max(xt)
            lnspc = np.linspace(xmin, xmax, len(residuals))
            # fit laplace distribution to histogram
            m, s = stats.norm.fit(residuals)  # get mean and standard deviation
            pdf_g = stats.norm.pdf(lnspc, m, s)  # now get theoretical values in the interval
            plt.plot(lnspc, pdf_g, label="Normal pdf fit")  # plot it
            if title == 'Histogram of residuals':
                title = 'Histogram of residuals' + ',' + r'$\bf{\mu=%.3f,\ \sigma=%.3f}$' % (m, s)
            plt.title(title, fontsize=14)
        else:
            plt.title(title, fontsize=14)

        plt.xlabel('Error values, [nT]', fontsize=14)
        plt.ylabel('Count', fontsize=14)
        ax = plt.gca()
        ax.yaxis.grid(which='major', color='grey', linestyle='dashed')
        ax.xaxis.grid(which='major', color='grey', linestyle='dashed')
        ax.set_axisbelow(True)
    else:
        print('Error: Please choose either "norm" for normal distributed residuals, '
              'or "laplace" for laplace distributed residuals')

    if savefig:
        plt.savefig('Error_histogram.png')

    plt.show()

    return


def plot_L_curve(misfit_norm_list, model_norm_list, alpha_index, truncate=False, point=True, savefig=False):
    """
    Plots the L curve, and places a red dot on the chosen alpha as default

    Args:
        misfit_list (float ndarray): list of misfit values for models evaluated at different alphas
        model_norm_list (float ndarray): list of model norm values for models evaluated at different alphas
        alpha_index (int): the index of the alpha corresponding to a set of [misfit, model_norm]-coordinates.
        truncate (int): option to not include the first elements of misfit_list and model_norm_list
        point (boolean): set to False if the coordinate-point, corresponding to the chosen alpha should not be plotted.
        savefig (boolean): save figure defaults False

    Returns:
        None

    @author: Eigil Y. H. Lippert, Student DTU Space, <s132561@student.dtu.dk>
    """

    fig, ax = plt.subplots()
    ax.plot(misfit_norm_list, model_norm_list, 'b.', label='L-curve')
    if truncate:
        ax.plot(misfit_norm_list[truncate::], model_norm_list[truncate::], 'g.', label='L-curve, truncated')
        misfit_norm_list = misfit_norm_list[truncate::]
        model_norm_list = model_norm_list[truncate::]

    if point:
        ax.plot(misfit_norm_list[alpha_index], model_norm_list[alpha_index], 'ro', label=r'$\alpha^2$')

    ax.set_xscale("log", basex=10)
    ax.set_yscale("log", basey=10)
    ax.set_xlabel('Misfit 2-norm, log-scale')
    ax.set_ylabel('Model norm, log-scale')
    #
    ax.grid(True, which="both", ls="-")
    ax.minorticks_on()

    ax.set_title('L-curve', fontsize=14, fontweight='bold')
    plt.legend()
    if savefig:
        string = 'L_curve' + '.png'
        plt.savefig(string)

    plt.show()
    return


def power_spectrum(model, ratio, degree, plot=True, savefig=False):
    '''
    Computes the Mauersberger-Lowes power spectrum, based on model parameters
    model   = array or list of model coefficients
    ratio   = ratio given like a/r, where a is the reference radius and r the radius of interest.
    degree  = maximum degree of the model.
    :param savefig:
    :return: wn, a vector of power sepctrum values at different degrees

    @author: Eigil Y. H. Lippert, Student DTU Space, <s132561@student.dtu.dk>

    '''
    # initialisation
    wn = []

    # counts the current coefficient order
    c = 0

    #initial value for the index
    idx = 0
    while c <= degree * (degree + 2):

        # determines the degree based on the current order
        n = -1 + np.sqrt(1 + c)

        # check if current degree is integer
        is_integer = (n - int(n))

        # if the current degree is a integer, then add the squared coefficients to wn[i]
        if is_integer == 0 and n > 0:
            if int(n) == 1:
                wn.append((n + 1) * ratio ** (2 * n + 4) * np.sum(model[idx:3] ** 2))
                idx = 3
            else:
                wn.append((n + 1) * ratio ** (2 * n + 4) * np.sum(model[idx:int(c - 1)] ** 2))
                idx = int(c - 1)
        c += 1

    if plot:
        degree_range = np.arange(1, degree + 1)

        fig, ax = plt.subplots(figsize=(10, 6))
        plt.semilogy(degree_range, wn, 'r-', label='model')

        plt.legend(fontsize=14)
        plt.title('Mauersberger-Lowes Power Spectrum', fontsize=22, fontweight='bold')
        plt.xlabel(r'$\bf{Spherical\ Harmonic\ Degree,\ \it{n}}$', fontsize=18, fontweight='bold')
        plt.ylabel(r'$\bf{R_n}$' + r'$,\ [(nT)^2]$', fontsize=18, fontweight='bold')
        ax.set_xticks(range(0, degree + 1))
        ax.get_xaxis().set_major_formatter(ticker.ScalarFormatter())
        ax.tick_params(axis='both', labelsize=10)
        plt.grid()

        if savefig:
            string = 'power_spectrum' + '.png'
            plt.savefig(string)

        plt.show()

    return wn